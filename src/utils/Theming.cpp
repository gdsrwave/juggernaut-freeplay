// Copyright 2025 GDSRWave
#include "Theming.hpp"
#include <algorithm>
#include <fstream>
#include <string>
#include <vector>
#include <Geode/Geode.hpp>
#include <Geode/utils/cocos.hpp>
#include <Geode/utils/file.hpp>
#include "./Ninja.hpp"
#include "./shared.hpp"

using namespace geode::prelude;

// the theme parsing in JFP uses a fully sandboxed script and
// evaluates a few simple, controlled arithmetic operations
// per each added block. there is no arbitrary code being installed
// or run by this mod; JFPT language is the closest you'll find. -M
namespace ThemeGen {

std::array<int, 3> hexToColor(const std::string& hex) {
    std::array<int, 3> color = {255, 255, 255};
    if (hex.size() == 7 && hex[0] == '#') {
        color[0] = geode::utils::numFromString<int>(hex.substr(1, 2), 16).unwrapOr(0);
        color[1] = geode::utils::numFromString<int>(hex.substr(3, 2), 16).unwrapOr(0);
        color[2] = geode::utils::numFromString<int>(hex.substr(5, 2), 16).unwrapOr(0);
    }
    return color;
}

// orientationMatch, but modified to account for miniwave and transitions
bool strictOM(const std::vector<JFPGen::Segment>& segments, int idx,
        const std::vector<int>& pattern, OMType omType, bool typeA) {
    if (idx < static_cast<int>(pattern.size())) return false;
    int y_swing = 0;
    bool mini = false;
    for (int i = 0; i < pattern.size(); i++) {
        auto seg = segments[idx - pattern.size() + i];
        y_swing = seg.y_swing;
        mini = seg.options.mini;

        if (typeA && seg.options.isTransition) {
            if (omType == OMType::Floor &&
                    ((mini && y_swing == 1) || (!mini && y_swing == -1))) {
                y_swing *= 2;
            } else if (omType == OMType::Ceiling &&
                    ((mini && y_swing == -1) || (!mini && y_swing == 1))) {
                y_swing *= 2;
            } else if (omType == OMType::Corridor) {
                return false;
            }
        } else if (mini) {
            y_swing *= 2;
        }
        if (y_swing != pattern[i]) return false;
    }
    return true;
}

std::string handleRawBlock(std::string addBlockLine, OMType omType) {
    std::string res;
    size_t start = 0;

    if (!addBlockLine.empty() && addBlockLine.back() == ';') addBlockLine.pop_back();
    while (start < addBlockLine.size()) {
        size_t comma = addBlockLine.find(',', start);
        std::string k = addBlockLine.substr(start, comma - start);
        start = (comma == std::string::npos) ? addBlockLine.size() : comma + 1;

        comma = addBlockLine.find(',', start);
        std::string v = addBlockLine.substr(start, comma - start);
        start = (comma == std::string::npos) ? addBlockLine.size() : comma + 1;

        int key = 0;
        key = geode::utils::numFromString<int>(k).unwrapOr(-1);
        if (key == -1) {
            continue;
        }

        // in 2.2, block/"GameObject"s' data will always have attributes 155
        // and 156 applied to them. these are automatically generated by GD
        // using a currently unknown technique, and when they are mismatched,
        // issues such as block flickering, incorrectly set colors, incorrectly
        // changing colors etc. will appear when a level is played. because of
        // this, JFP will strip these values. if you face issues with removing
        // these values, I unfortunately don't have a great answer; all I can
        // do is suggest you create theme segments in 2.1 instead. thanks for
        // understanding. -M
        if (key == 155 || key == 156) continue;

        if (key == 2) {
            float xv = geode::utils::numFromString<float>(v).unwrapOr(0.f);
            if (xv == 0.f) {
                continue;
            }
            if (std::abs(xv - std::round(xv)) < 0.1f) {
                xv = std::round(xv);
                v = geode::utils::numToString(static_cast<int>(xv));
            }
            if (omType != OMType::None) v = "[X+" + v + "]";
        } else if (key == 3) {
            float yv = geode::utils::numFromString<float>(v).unwrapOr(0.f);
            // num = geode::utils::numFromString<float>(numStr).unwrapOr(0.f);
            if (yv == 0.f) {
                continue;
            }
            if (std::abs(yv - std::round(yv)) < 0.1f) {
                yv = std::round(yv);
                v = geode::utils::numToString(static_cast<int>(yv));
            }
            if (omType == OMType::Ceiling) v = "[Y+C+" + v + "]";
            else if (omType != OMType::None) v = "[Y+" + v + "]";
        }

        if (!res.empty()) res += ",";
        res += k + "," + v;
    }
    return res;
}

std::string parseAddBlock(std::string addBlockLine, float X, float Y,
        int maxHeight, int minHeight, int corridorHeight) {
    // remove legacy prefix
    if (addBlockLine.empty()) return "";
    const std::string prefix = "Add Block";
    auto pos = addBlockLine.find(prefix);
    if (pos != std::string::npos) {
        addBlockLine = addBlockLine.substr(pos + prefix.length());
    }

    addBlockLine.erase(0, addBlockLine.find_first_not_of(" \t\r\n"));
    addBlockLine.erase(addBlockLine.find_last_not_of(" \t\r\n") + 1);

    // eval bracketed arithmetic
    std::string result;
    size_t i = 0;
    while (i < addBlockLine.size()) {
        if (addBlockLine[i] == '[') {
            size_t end = addBlockLine.find(']', i);
            if (end != std::string::npos) {
                std::string expr = addBlockLine.substr(i + 1, end - i - 1);

                expr.erase(remove_if(expr.begin(), expr.end(), ::isspace), expr.end());
                float value = 0.f;

                // throw in xpos, ypos, corridorheight values
                std::string parsedExpr;
                for (size_t j = 0; j < expr.size(); ++j) {
                    if (expr[j] == 'X') {
                        parsedExpr += geode::utils::numToString(X);
                    } else if (expr[j] == 'Y') {
                        parsedExpr += geode::utils::numToString(Y);
                    } else if (expr[j] == 'C') {
                        parsedExpr += geode::utils::numToString(corridorHeight);
                    } else {
                        parsedExpr += expr[j];
                    }
                }

                // evaluate the parsedExpr as a left-to-right sum/diff/prod/quot
                float acc = 0.f;
                char lastOp = 0;
                size_t idx = 0;
                while (idx < parsedExpr.size()) {
                    size_t nextOp = parsedExpr.find_first_of("+-*/", idx);
                    std::string numStr = parsedExpr.substr(idx, nextOp - idx);
                    float num = geode::utils::numFromString<float>(numStr).unwrapOr(0.f);
                    if (lastOp == 0) {
                        acc = num;
                    } else if (lastOp == '+') {
                        acc += num;
                    } else if (lastOp == '-') {
                        acc -= num;
                    } else if (lastOp == '*') {
                        acc *= num;
                    } else if (lastOp == '/') {
                        acc /= num;
                    }
                    if (nextOp == std::string::npos) break;
                    lastOp = parsedExpr[nextOp];
                    idx = nextOp + 1;
                }
                value = acc;

                // TODO(M): rework this - it's intended to cut around
                // the field of view to prevent obj hell. should probably
                // rework the simple arithmetic logic as well, at some point
                if (expr.find("Y") != std::string::npos) {
                    if (value > 375 || value < -15) {
                        return "";
                    }
                }

                result += geode::utils::numToString(static_cast<int>(value));
                i = end + 1;
            } else {
                result += addBlockLine[i++];
            }
        } else {
            result += addBlockLine[i++];
        }
    }

    if (!result.empty() && result.back() != ';') {
        result += ';';
    }
    return result;
}

std::string parseTheme(const std::string& name, const JFPGen::LevelData& ldata) {
    bool inMetadata = false;
    bool inAddcolor = false;
    bool inKValues = false;
    bool inMatches = false;
    bool inPattern = false;
    InOverride inOverride = InOverride::None;
    bool inOverrideMini = false;

    RepeatingPattern patternGen = RepeatingPattern();
    ThemeMatch cMP = ThemeMatch();
    ThemeMetadata metadata;
    std::vector<std::vector<ThemeMatch>> matchConditions;
    std::vector<ThemeMatch> cMPList;
    std::vector<RepeatingPattern> repeatingPatterns;
    std::string themeGen = "";
    std::string corridorBlock = "";

    for (const auto& key : {
        "override-base", "override-start", "override-enddown",
        "override-endup", "override-slope", "override-slope-mini"
    }) {
        overrideBank[key] = false;
    }

    JFPGen::Color sColor = JFPGen::Color();

    auto biome = ldata.biomes[0];

    auto localPath = CCFileUtils::sharedFileUtils();
    std::string themeName = name;
    if (themeName.size() < 5 || themeName.substr(themeName.size() - 5) != ".jfpt") {
        themeName += ".jfpt";
    }
    std::string fp = std::string(localPath->getWritablePath()) +
        "/jfp/themes/" + themeName;
    std::ifstream file(fp);
    if (!file.is_open()) {
        return "";
    }
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(file, line)) {
        lines.push_back(line);
    }
    file.close();

    for (const auto& l : lines) {
        if (l == "# color #") {
            inAddcolor = true;
            continue;
        } else if (l == "# end color #") {
            inAddcolor = false;
            pushColor(sColor);
            sColor = JFPGen::Color();
            continue;
        }
        if (inAddcolor) {
            auto pos = l.find(':');
            if (pos != std::string::npos) {
                std::string key = l.substr(0, pos);
                std::string value = l.substr(pos + 1);

                key.erase(0, key.find_first_not_of(" \t\r\n"));
                key.erase(key.find_last_not_of(" \t\r\n") + 1);
                value.erase(0, value.find_first_not_of(" \t\r\n"));
                value.erase(value.find_last_not_of(" \t\r\n") + 1);

                if (key == "Color") {
                    if (value.size() > 4 && value.substr(0, 4) == "Copy") {
                        sColor.copyColor = geode::utils::numFromString<int>(value.substr(5)).unwrapOr(-1);
                    } else {
                        sColor.rgb = hexToColor(value);
                    }
                } else if (key == "Slot") {
                    sColor.slot = geode::utils::numFromString<int>(value).unwrapOr(13);
                } else if (key == "Blending") {
                    sColor.blending = (value == "true" || value == "1");
                } else if (key == "Opacity") {
                    sColor.opacity = geode::utils::numFromString<float>(value).unwrapOr(1.0f);
                } else if (key == "Special") {
                    sColor.special = value;
                }
            }
            continue;
        }

        if (l.find("# define") == 0 && l.back() == '#') {
            std::string cmd = l.substr(9, l.size() - 11);
            cmd.erase(0, cmd.find_first_not_of(" \t\r\n"));
            cmd.erase(cmd.find_last_not_of(" \t\r\n") + 1);

            if (cmd == "base") {
                inOverride = InOverride::Base;
                overrideBank["override-base"] = true;
                continue;
            } else if (cmd == "corridorblock") {
                inOverride = InOverride::CorridorBlock;
                continue;
            }

            if (cmd.size() > 5 && cmd.substr(cmd.size() - 5) == "-mini") {
                cmd = cmd.substr(0, cmd.size() - 5);
                inOverrideMini = true;
            } else {
                inOverrideMini = false;
            }
            if (cmd == "enddown") {
                inOverride = InOverride::EndDown;
                overrideBank["override-enddown"] = true;
            } else if (cmd == "endup") {
                inOverride = InOverride::EndUp;
                overrideBank["override-endup"] = true;
            } else if (cmd == "start") {
                inOverride = InOverride::Start;
                overrideBank["override-start"] = true;
            } else if (cmd == "slope") {
                inOverride = InOverride::Slope;
                overrideBank[inOverrideMini
                    ? "override-slope-mini"
                    : "override-slope"] = true;
            }
            continue;
        } else if (l == "# end define #") {
            inOverride = InOverride::None;
            continue;
        }

        if (inOverride == InOverride::Base) {
            themeGen += parseAddBlock(
                l,
                0,
                0,
                biome.options.maxHeight,
                biome.options.minHeight,
                biome.options.corridorHeight);
            continue;
        } else if (inOverride == InOverride::Start) {
            if (biome.options.startingMini == inOverrideMini) {
                int passedCH = biome.options.corridorHeight;
                if (inOverrideMini && biome.options.typeA) passedCH += 30;
                themeGen += parseAddBlock(
                    l,
                    0,
                    0,
                    biome.options.maxHeight,
                    biome.options.minHeight,
                    passedCH);
            }
            continue;
        } else if (inOverride == InOverride::EndUp &&
                biome.segments.back().y_swing == 1) {
            if (biome.segments.back().options.mini == inOverrideMini) {
                int passedCH = biome.options.corridorHeight;
                if (inOverrideMini && biome.options.typeA) passedCH += 30;
                themeGen += parseAddBlock(
                    l,
                    biome.segments.back().coords.first,
                    biome.segments.back().coords.second,
                    biome.options.maxHeight,
                    biome.options.minHeight,
                    passedCH);
            }
            continue;
        } else if (inOverride == InOverride::EndDown &&
                biome.segments.back().y_swing == -1) {
            if (biome.segments.back().options.mini == inOverrideMini) {
                int passedCH = biome.options.corridorHeight;
                if (inOverrideMini && biome.options.typeA) passedCH += 30;
                themeGen += parseAddBlock(
                    l,
                    biome.segments.back().coords.first,
                    biome.segments.back().coords.second,
                    biome.options.maxHeight,
                    biome.options.minHeight,
                    passedCH);
            }
            continue;
        } else if (inOverride == InOverride::CorridorBlock) {
            corridorBlock = l;
        }

        if (l == "# k #") {
            inKValues = true;
            continue;
        } else if (l == "# end k #") {
            inKValues = false;
            continue;
        }
        if (inKValues) {
            auto pos = l.find(':');
            if (pos != std::string::npos) {
                std::string key = l.substr(0, pos);
                std::string value = l.substr(pos + 1);

                key.erase(0, key.find_first_not_of(" \t\r\n"));
                key.erase(key.find_last_not_of(" \t\r\n") + 1);
                value.erase(0, value.find_first_not_of(" \t\r\n"));
                value.erase(value.find_last_not_of(" \t\r\n") + 1);

                kBank[key] = value;
            }
            continue;
        }

        if (!l.empty() &&
                ((l.find("# if ") == 0 && l.back() == '#') ||
                (l.find("# else if ") == 0 && l.back() == '#'))) {
            inMatches = true;
            if (l.find("# if ") == 0) {
                cMP = ThemeMatch();
            } else if (l.find("# else if ") == 0) {
                if (!cMP.pattern.empty() || !cMP.notPatterns.empty()) {
                    cMPList.push_back(cMP);
                    cMP = ThemeMatch();
                }
            }

            std::string condition = l.substr(2, l.size() - 4);
            std::vector<std::string> tokens;
            size_t start = 0, end = 0;
            while ((end = condition.find(" and ", start)) != std::string::npos) {
                tokens.push_back(condition.substr(start, end - start));
                start = end + 5;
            }
            tokens.push_back(condition.substr(start));

            for (const auto& token : tokens) {
                std::string t = token;

                t.erase(0, t.find_first_not_of(" \t\r\n"));
                t.erase(t.find_last_not_of(" \t\r\n") + 1);

                size_t corridorPos = t.find("corridor");
                size_t floorPos = t.find("floor");
                size_t ceilingPos = t.find("ceiling");
                OMType omType;
                if (corridorPos != std::string::npos) omType = OMType::Corridor;
                else if (floorPos != std::string::npos) omType = OMType::Floor;
                else if (ceilingPos != std::string::npos) omType = OMType::Ceiling;
                else continue;

                bool isNot = false;
                size_t notPos = t.find("not matches");
                size_t matchesPos = t.find("matches");
                if (notPos != std::string::npos) {
                    isNot = true;
                    t = t.substr(notPos + 12);
                } else if (matchesPos != std::string::npos) {
                    t = t.substr(matchesPos + 7);
                } else {
                    continue;
                }

                t.erase(0, t.find_first_not_of(" \t\r\n"));
                t.erase(t.find_last_not_of(" \t\r\n") + 1);

                // parse y_swing from brackets
                std::vector<int> pattern;
                int offset = 0;
                size_t bracketStart = t.find('[');
                size_t bracketEnd = t.find(']');
                std::string symbols = t;
                if (bracketStart != std::string::npos &&
                        bracketEnd != std::string::npos && bracketEnd > bracketStart) {
                    symbols = t.substr(0, bracketStart);
                    std::string offsetStr = t.substr(
                        bracketStart + 1, bracketEnd - bracketStart - 1);

                    int displacement = 0;
                    for (size_t idx = bracketEnd + 1; idx < t.size(); ++idx) {
                        if (t[idx] == '+' || t[idx] == '-' ||
                                t[idx] == '/' || t[idx] == '\\') {
                            displacement++;
                        }
                    }
                    offset = displacement;
                }

                t.erase(remove_if(t.begin(), t.end(), ::isspace), t.end());
                for (char ch : t) {
                    if (ch == '+') pattern.push_back(1);
                    else if (ch == '-') pattern.push_back(-1);
                    else if (ch == '/') pattern.push_back(2);
                    else if (ch == '\\') pattern.push_back(-2);
                }

                std::string patternStr;
                for (size_t pi = 0; pi < pattern.size(); ++pi) {
                    patternStr += geode::utils::numToString(pattern[pi]);
                    if (pi + 1 < pattern.size()) patternStr += ",";
                }

                if (!isNot) {
                    cMP.omType = omType;
                    cMP.pattern = pattern;
                    cMP.offset = offset;
                } else {
                    cMP.notTypes.push_back(omType);
                    cMP.notPatterns.push_back(pattern);
                    cMP.notOffsets.push_back(offset);
                }
            }
            continue;
        }
        if (l == "# else #") {
            if (!cMP.pattern.empty() || !cMP.notPatterns.empty()) {
                cMPList.push_back(cMP);
                cMP = ThemeMatch();
                cMP.omType = OMType::Corridor;
                cMP.notTypes = {};
                cMP.pattern = {};
                cMP.offset = 0;
                cMP.notPatterns = {};
                cMP.notOffsets = {};
                cMP._else = true;
            }
            continue;
        } else if (l == "# end if #") {
            inMatches = false;

            if (cMP._else || !cMP.pattern.empty() || !cMP.notPatterns.empty()) {
                cMPList.push_back(cMP);
                cMP = ThemeMatch();
            }
            matchConditions.push_back(cMPList);
            cMPList = std::vector<ThemeMatch>();
            continue;
        }
        if (inMatches) {
            cMP.commands.push_back(l);
            continue;
        }

        if (l == "# pattern #") {
            inPattern = true;
            continue;
        } else if (l == "# end pattern #") {
            inPattern = false;
            if (!patternGen.data.empty()) {
                repeatingPatterns.push_back(patternGen);
                patternGen = RepeatingPattern();
            }
            continue;
        }
        if (inPattern) {
            auto pos = l.find(':');
            if (pos != std::string::npos) {
                std::string key = l.substr(0, pos);
                std::string value = l.substr(pos + 1);

                key.erase(0, key.find_first_not_of(" \t\r\n"));
                key.erase(key.find_last_not_of(" \t\r\n") + 1);
                value.erase(0, value.find_first_not_of(" \t\r\n"));
                value.erase(value.find_last_not_of(" \t\r\n") + 1);

                if (key == "Data") {
                    patternGen.data = value;
                } else if (key == "Start") {
                    patternGen.start = geode::utils::numFromString<int>(value).unwrapOr(195);
                } else if (key == "Repeat") {
                    patternGen.repeat = geode::utils::numFromString<int>(value).unwrapOr(30);
                    if (patternGen.repeat < 1 && patternGen.repeat != 30) {
                        patternGen.repeat = 1;
                    }
                }
            }
            continue;
        }
    }


    const int trueLength = (biome.options.length * 30);
    for (const auto& pattern : repeatingPatterns) {
        int loopCount = std::min((trueLength / pattern.repeat) + 1, 1000);
        int n = pattern.start;
        for (int i = 0; i < loopCount; ++i) {
            themeGen += parseAddBlock(
                pattern.data,
                n, 0,
                biome.options.maxHeight,
                biome.options.minHeight,
                biome.options.corridorHeight);
            n += pattern.repeat;
        }
    }

    for (int i = 0; i < biome.segments.size(); i++) {
        const auto& seg = biome.segments[i];

        int passedCH = biome.options.corridorHeight;
        if (seg.options.mini && biome.options.typeA) passedCH += 30;

        if (corridorBlock != "") {
            int numCB = (passedCH / 30) - (seg.options.mini ? 2 : 1);
            for (int j = 1; j <= numCB; j++) {
                themeGen += parseAddBlock(
                    corridorBlock, seg.coords.first, seg.coords.second + j*30,
                    biome.options.maxHeight, biome.options.minHeight, passedCH);
            }
        }

        if (seg.options.isTransition) {
            if (seg.y_swing == 1 && !seg.options.mini) passedCH += 30;
            else if (seg.y_swing == 1 && seg.options.mini) passedCH -= 30;
        }

        for (const auto& condition : matchConditions) {
            for (const auto& match : condition) {
                bool successfulMatch = false;

                bool notPatternsOk = true;
                for (int np = 0; np < match.notPatterns.size(); ++np) {
                    if (strictOM(
                            biome.segments,
                            i + match.notOffsets[np] + 1,
                            match.notPatterns[np],
                            match.notTypes[np],
                            biome.options.typeA)) {
                        notPatternsOk = false;
                        break;
                    }
                }

                if (notPatternsOk &&
                    (strictOM(
                        biome.segments,
                        i + match.offset + 1,
                        match.pattern,
                        match.omType,
                        biome.options.typeA) ||
                      (match._else && match.pattern.empty()))) {
                    for (const auto& cmd : match.commands) {
                        std::string parsed = parseAddBlock(
                            cmd, seg.coords.first, seg.coords.second,
                            biome.options.maxHeight, biome.options.minHeight, passedCH);
                        if (!parsed.empty()) {
                            themeGen += parsed;
                        }
                    }
                    successfulMatch = true;
                }

                if (successfulMatch) {
                    break;
                }
            }
        }
    }

    return themeGen;
}

ThemeMetadata parseThemeMeta(const std::string& name) {
    bool inMetadata = false;
    ThemeMetadata metadata;

    auto localPath = CCFileUtils::sharedFileUtils();
    std::string themeName = name;
    if (themeName.size() < 5 || themeName.substr(themeName.size() - 5) != ".jfpt") {
        themeName += ".jfpt";
    }
    std::string fp = std::string(localPath->getWritablePath()) +
        "/jfp/themes/" + themeName;
    std::ifstream file(fp);
    if (!file.is_open()) {
        return ThemeMetadata();
    }
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(file, line)) {
        lines.push_back(line);
    }
    file.close();

    for (const auto& l : lines) {
        // TODO(M): rework into a switch case or a neater conditional
        if (l == "# metadata #") {
            inMetadata = true;
            continue;
        } else if (l == "# end metadata #") {
            inMetadata = false;
            continue;
        }
        if (inMetadata) {
            auto pos = l.find(':');
            if (pos != std::string::npos) {
                std::string key = l.substr(0, pos);
                std::string value = l.substr(pos + 1);

                key.erase(0, key.find_first_not_of(" \t\r\n"));
                key.erase(key.find_last_not_of(" \t\r\n") + 1);
                value.erase(0, value.find_first_not_of(" \t\r\n"));
                value.erase(value.find_last_not_of(" \t\r\n") + 1);

                if (key == "Name") metadata.name = value;
                else if (key == "Author") metadata.author = value;
                else if (key == "Version") metadata.version = value;
                else if (key == "Biome") metadata.biome = value;
                else if (key == "Tags") {
                    metadata.tags.clear();
                    size_t start = 0, end = 0;
                    while ((end = value.find(", ", start)) != std::string::npos) {
                        metadata.tags.push_back(value.substr(start, end - start));
                        start = end + 2;
                    }
                    metadata.tags.push_back(value.substr(start));
                }
                else if (key == "Date") metadata.date = value;
                else if (key == "Pack") metadata.pack = value;
                else if (key == "Type") metadata.type = value;
                else if (key == "Description") metadata.description = value;
            }
            continue;
        }
    }

    return metadata;
}

std::vector<std::string> tagConflicts(ThemeMetadata tmd) {
    auto* mod = Mod::get();
    std::vector<std::string> conflicts;

    const bool isBigPresent =
            mod->getSettingValue<std::string>("starting-size") == "Big" ||
        mod->getSettingValue<bool>("changing-size");
    const bool isMiniPresent =
            mod->getSettingValue<std::string>("starting-size") == "Mini" ||
        mod->getSettingValue<bool>("changing-size");
    const bool isTypeA = mod->getSettingValue<bool>("changing-size") &&
        (mod->getSettingValue<std::string>("transition-type") == "Type A" ? true : false);

    if (isMiniPresent && std::find(tmd.tags.begin(), tmd.tags.end(), "bigwave-only") !=
            tmd.tags.end()) {
        conflicts.push_back("bigwave-only");
    }
    if (isBigPresent && std::find(tmd.tags.begin(), tmd.tags.end(), "miniwave-only") !=
            tmd.tags.end()) {
        conflicts.push_back("miniwave-only");
    }
    if (isTypeA && std::find(tmd.tags.begin(), tmd.tags.end(), "type-b-only") !=
            tmd.tags.end()) {
        conflicts.push_back("type-b-only");
    }
    if (!isTypeA && std::find(tmd.tags.begin(), tmd.tags.end(), "type-a-only") !=
            tmd.tags.end()) {
        conflicts.push_back("type-a-only");
    }

    return conflicts;
}

}  // namespace ThemeGen
